unit ClassesToTest;

// This unit contains the classes used for the autofixture examples
// There are classes containing test data, as well as interfaces,
// and the classes that are going to be tested

interface

uses
  Generics.Collections;

type

// CLASSES CONTAINING TEST DATA (Not code classes)
TSteeringWheel = class
protected
  FDirectionAngle: Double;
public
  property DirectionAngle: Double read FDirectionAngle write FDirectionAngle;
end;

TControlPanel = class
protected
  FIgnition: Boolean;
  FSteeringWheel: TSteeringWheel;
public
  property IsIgnitionOn: Boolean read FIgnition write FIgnition;
  constructor Create(ASteeringWheel: TSteeringWheel);
end;

TWheel = Class
protected
  FTyrePreassure: Integer;
public
  property TyrePreassure: Integer read FTyrePreassure write FTyrePreassure;
End;

TSeat = Class
protected
  FHeat: Boolean;
public
  property isHeatOn: Boolean read FHeat write FHeat;
End;

TNumberPlate = Class
protected
  FNumber: String;
public
  property Number: String read FNumber;
  constructor Create(ANumber: String);
End;

// INTERFACES
IUnitUnderTest = interface(IInterface)
  Function SimpleConcatTest(Astring1, Astring2: String): String;
end;

IExternalDependence = interface(IInterface)
  Function DoExternalWork(AString: String): String;
end;

// CLASSES TO TEST

TUnitUnderTest = class(TInterfacedObject, IUnitUnderTest)
protected
  FInjectedExternalDependence: IExternalDependence;
public
  Function SimpleConcatTest(Astring1, Astring2: String): String;
  constructor Create(AExternalDependence: IExternalDependence);
end;

TExternalDependence = class(TInterfacedObject, IExternalDependence)
  Function DoExternalWork(AString: String): String; virtual;
end;

TCar = class
private
  FControls: TControlPanel;
  FNumberPlate: TNumberPlate;
  FWheels: TObjectList<TWheel>;
  FSeats: TObjectList<TSeat>;
public
  ///<summary>Injects a control panel and a numberplate class, these are mostly used as an example of classes autogenerated by AutoFixture</summary>
  constructor Create(AControlPanel: TControlPanel; ANumberPlate: TNumberPlate);
  Procedure AddWheelInfo(AWheel: TWheel);
  Procedure AddSeatInfo(ASeat: TSeat);
  Function IsTyrePreassureOK: Boolean;
end;

implementation

uses
  System.SysUtils;

{ TUnitUnderTest }

constructor TUnitUnderTest.Create(AExternalDependence: IExternalDependence);
begin
  FInjectedExternalDependence := AExternalDependence;
end;

function TUnitUnderTest.SimpleConcatTest(Astring1, Astring2: String): String;
begin
  Result := FInjectedExternalDependence.DoExternalWork(AString1 + AString2);
end;

{ TExternalDependence }

function TExternalDependence.DoExternalWork(AString: String): String;
begin
  raise Exception.Create('External work may never be called during unit testing!');
end;

{ TCar }

procedure TCar.AddSeatInfo(ASeat: TSeat);
begin
  FSeats.Add(ASeat);
end;

procedure TCar.AddWheelInfo(AWheel: TWheel);
begin
  FWheels.Add(AWheel);
end;

constructor TCar.Create(AControlPanel: TControlPanel; ANumberPlate: TNumberPlate);
begin
  FSeats := TObjectList<TSeat>.Create(True);
  FWheels := TObjectList<TWheel>.Create(true);
  FControls := AControlPanel;
  FNumberPlate := ANumberPlate;
  if FNumberPlate.Number = '' then begin
    raise Exception.Create('Can''t drive car without numberplate!');
  end;
end;

function TCar.IsTyrePreassureOK: Boolean;
var
  vTyre: TWheel;
begin
  if not FControls.IsIgnitionOn then begin
    raise Exception.Create('Can''t test with ignition off');
  end;

  if FWheels.Count <> 4 then begin
    raise Exception.Create('Possible tyre sensor malfunction');
  end
  else begin
    Result := True;
    for vTyre in FWheels do begin
      if (vTyre.TyrePreassure < 90) or (vTyre.TyrePreassure > 120) then begin
        Result := False; // Preassure is measured in percent of normal
      end;
    end;
  end;
end;

{ TNumberPlate }

constructor TNumberPlate.Create(ANumber: String);
begin
  FNumber := ANumber;
end;

{ TControlPanel }

constructor TControlPanel.Create(ASteeringWheel: TSteeringWheel);
begin
  FSteeringWheel := ASteeringWheel;
end;

end.
